<h1 id="--">Динамическое распределение памяти</h1>
<p>Время жизни динамически размещаемых данных определяется самой программой в процессе её выполнения, в отличие от статически определённых данных, чьё время жизни задаётся заранее.<br />
Если программе требуется дополнительная память для хранения данных, она может запросить её во время работы, используя стандартные средства языка программирования.<br />
Когда данные больше не нужны, область памяти, выделенная под них, может быть освобождена.</p>
<p>Таким образом, распределение памяти возложено на программу (или программиста), что даёт большую гибкость, но одновременно требует внимательности и аккуратности.</p>
<h3 id="---">Особенности динамически размещаемых данных:</h3>
<ol>
<li>В отличие от заранее определённых данных, они <strong>не имеют имён</strong>, и доступ к ним осуществляется только через указатели.</li>
<li>Память под них выделяется <strong>во время выполнения программы</strong>, а не на этапе компиляции.</li>
<li>Благодаря этому, память можно как выделять, так и освобождать непосредственно в процессе работы программы, подстраивая использование ресурсов под реальные потребности.</li>
</ol>
<hr />
<h2 id="--c----">Средства языка C для динамического распределения памяти</h2>
<p>Для работы с динамически распределяемой памятью в языке C существует ряд функций, описанных в библиотеке <strong><code>stdlib.h</code></strong>. Чтобы использовать их, необходимо подключить эту библиотеку:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
</code></pre>
<h2 id="---void---c">Преобразование указателя типа <code>void</code> в языке C</h2>
<p>Тип <strong><code>void</code></strong> является особым: в отличие от других базовых типов данных, он не имеет ни набора допустимых значений, ни набора операций. Поэтому невозможно описывать обычные переменные типа <code>void</code>, так как им нельзя присвоить значение.</p>
<p>Тем не менее, <code>void</code> введён для выполнения специальных функций:</p>
<ol>
<li>
<p>Указание того, что функция <strong>не возвращает</strong> значения:</p>
<pre><code class="language-c">void FuncName() { ... }
</code></pre>
</li>
<li>
<p>Указание того, что функция <strong>не принимает аргументов</strong>:</p>
<pre><code class="language-c">int FuncName(void) { ... }
</code></pre>
</li>
<li>
<p>Объявление указателя на тип <code>void</code>:</p>
<pre><code class="language-c">void *ptr;
</code></pre>
<p>Такой указатель является универсальным — он может указывать на данные любого типа. Однако для работы с ними требуется явное преобразование (<code>casting</code>) к нужному типу:</p>
<pre><code class="language-c">int *p = (int *)malloc(sizeof(int));
</code></pre>
</li>
</ol>
<hr />
<pre><code class="language-c">int *px;
float *py;
int x = 1;
float y = 1.6;

px = &amp;x;
py = &amp;y;

void *z; //для того чтобы можно было работать с *z* мы должны его преобразовать
// величина типа указатель на void может быть преобразована к величине льбого другого указательного типа
int *px; px = &amp;x;
float *py; py = &amp;y;
void *z; (int *)z = px; (float *)z = py;

// наш указатель z указывает не на адрес конкретного объекта программы, а указывает на адрес памяти по которому может храниться любой объект некоторого типа поэтому указатель на тип void называют адресным указателем
//это для того чтобы не писать множество однотипных ф-й возвращающих указатели на разные типы данных, и эта воз-ть используется и в динамическом распределении данных

// очень часто ф-ии возвращают указатель типа void

int main (){
    ...
    int *px;
    float *py;
    ...
    px = (int *)F(...);
    py = (float *)F(...);

    return 0;
}

void *F(...){...}
//возвращает чисто адрес (типо одной ячейки), а там уже расширяем количество ячеек для указателя

</code></pre>
<hr />
<h2 id="-------">Ф-ии языка С для создания динамических данных</h2>
<ol>
<li><code>malloc</code> - функция выделяет блок памяти размером как минимум <code>size</code> байт.<br />
В качестве своего значения функция возвращает указатель на выделенную область памяти, начинающуюся на границе слова.<br />
При выделении блока памяти происходит его выравнивание для размещения объектов любого типа.<br />
При этом инициализация блока памяти нулями не производится.</li>
</ol>
<pre><code class="language-c">void *malloc(unsigned int size); //заголовок
                        // ^- это объем памяти который необходимо 

</code></pre>
<ol start="2">
<li><code>calloc</code> - динамически выделяет область памяти nelem (количество элементов) по elsize памяти и возвращает указатель на первый элемент массива, также как для ф-ии malloc происходит его выравнивание на границу слова.<br />
<em>Отличие от malloc</em>: происходит авто обнуление выделяемой памяти</li>
</ol>
<pre><code class="language-c">//                           колво этементов которому нужно выделить
//                           |                 память на каждую переменную
//                           V                  V
void *calloc(unsigned int nelem, unsigned int elsize); 
</code></pre>
<ol start="3">
<li><code>realloc</code> - функция изменения размера памяти под динамические данные</li>
</ol>
